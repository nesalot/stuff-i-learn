## Follow metaphors with care

Software do not need to obey the laws of physics, and can be exponentially complex. Using metaphors blinds us from the reality/difficulty of the task at hand.

## Plan enough then build

It takes time to undo things that you make wrong. (That is not to say you should plan every detail, either.)

## Launch is just the first release

Don't feel like "it's over."

## The 'Ivory Tower' architect is a myth

The corporate ladder leads to less code as you move up, becoming less and less hands-on.

This makes you understand the big picture, but less capable of estimating how complex something is.

Ideally, you should be hands-on every once in a while.

## Throw away your old code

If some code is old, useless, *and* creates obstacles for your work ahead, delete it, and think of a better way to replement what you now need.

## Diversification over Specialisation

It's good to know at least a little of everything -- languages, UI, architectures... to get the big picture and the best way to tackle problems.

## Metaphors hide better ways of working

If a metaphor prevents you from communicating your true intents, ditch the metaphor. The metaphor does not fit here.

## The perks are in the work

Free food and foosball tables won't win people over -- what they can do at their jobs win them over.

Pick the job that motivates you.

## Begin where you love to begin

You can build software from wherever you like (e.g. models? views? the home page?) -- whichever motivates you.

## Be imperfect

Code is never perfect. You cannot be "OCD" about it; embrace a certain amount of entropy and move on.

## Stop programming

You program too much. 

Go outside a little.

Enjoy the real life.

## Test your work first thing in the morning

Start finding problems when you're the most motivated to work.

This also makes you forget the amount of work you did the day before.

## Work outside the bedroom

Maintain work-life balance. Avoid working from home, and not on the bed (where you rest).

Leave work, hang a "Closed" sign, and live your life.

## First impressions are just that

> Does your tool work? Yes? Will this new tool work for you? 

Sometimes people just don't know how to use your new tool. Let people get used to it, and have them be surprised how much better your tool really is. (if it is indeed better)

## The emotional value of Launch

Launching motivates you to work more on the software, because you now have users!

## Find an argument

Debate / Write an argument about why you choose to do things / pick tools / believe in that thing that you do (e.g. vim vs emacs).

Having something to believe in keeps you motivated.

## Just say no to the pet project

If a pet project distracts you from your main project, stop.

If a pet project exceeds its deadline, stop. The project has failed.

## Constrain all of your parameters

Have walls around time, cost, and feature set. Having real, predefined constraints lets us realise the problem and identify actual ways to move forward.

## Cut the detail out of the timeline

Plan in big chunks, because projects never go exactly as planned, and you are just wasting your time planning.

## Improve your product in two ways daily

Just a small goal to set to keep yourself motivated throughout the day.

## Invest in a good work environment

Buy a better keyboard, get a better desk... imagine the number of typos you didn't make! Productivity goes up, job satisfaction goes up.

## Keep a personal to-do list

Keep *one*, *flat* list of things just for yourself to check off, with four sections:

* Today
* Tomorrow
* Two days from now
* Future

Simple to-do lists are the most effective.

## Create "Off-time" with your team

Create a circle of times during the day where one person in the team can ignore everyone else in the team and work on his/her own with no interruption.

## Work on small, autonomous teams

Avoiding big teams lets small team members know each other better. This lowers turnover of members.

## Eliminate the "we" in productivity

You rarely mean "we" as in all of us; you almost always mean "some of us" e.g. the sales team, or "me" e.g. James.

"We" prevents naming people when you want feedback from particulars, and feeds the bystander effect ("I wasn't called")

## Sniff out bad complexity

Bad complexity is complexity that doesn't need to be there. Can you do things simpler? Can you write code that is easier to understand?

## The simplicity paradox

Simple code can be hard to build.

Simple code can be hard to expand.

Simple code can be lack features.

The perfect piece of software is one that does *exactly* what is expected of it -- no more, no less.

## Complexity as a game of pickup sticks

Implementing a feature is like adding a stick to the stick pile.

Removing the feature may disturb many other sticks.

Be careful what features you add, and whether they are necessary.

## Keep complexity under the surface

Let the software handle the underlying complexity -- the user doesn't need to know how things work.

## "Hard to code" might mean "hard to use"

In that case, you are neither shifting pain from users to the code, nor making software that is easy to maintain.

Think hard about why you are implementing this thing.

## Know when to refactor

Some kinds of refactoring make sense at the time they are done, but if given enough time, refactoring code might reduce the ability for some other, better ways to refactor the same code afterwards.

So, don't try to refactor too often.

## Develop a programming cadance

There is no silver bullet to knowing if you are anticipating too early for a change vs reacting too late for a change. You will get better at it over time.

# Teaching

Teaching isn't recalling what you know; teaching is presenting what you know to the person you are teaching.

This means just because you know a lot, it doesn't mean you teach well.

## Teaching is unlike coding

Teaching a new person: every bit you didn't teach is every bit lost. It is very hard to bring someone up to speed because you already have all the tools set up the way you wanted, all the environments working perfectly...

## Beware the "curse of knowledge"

You will take some of what you know for granted. To alleviate that, be aware of this effect.

## Teach with obvious examples

Think: why is `sally = new Human()` better than `newObject = new Object()`?

## Lie to simplify

It's okay to not say the perfect truth when you're teaching, if it gets in the way of understanding (see: structure of an atom)

## Enourage autonomous thought

Guide your student into thinking with their own heads -- not just the things you had taught.

Ways to trigger this include: setting a goal but not the method; getting them to offer alternatives; and guiding them through the "why" after "what" and "how".

# Clients

